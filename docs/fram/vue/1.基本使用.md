# vite 和 webpack 对比

webpack 会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。
而 vite 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。
由于现代浏览器本身就支持 ES Module，会自动向依赖的 Module 发出请求。vite 充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像 webpack 那样进行打包合并。
由于 vite 在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite 的优势越明显。
在 HMR 方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像 webpack 那样需要把该模块的相关依赖模块全部编译一次，效率更高。
当需要打包到生产环境时，vite 使用传统的 rollup 进行打包，因此，vite 的主要优势在开发阶段。另外，由于 vite 利用的是 ES Module，因此在代码中不可以使用 CommonJS

# vue3 的效率提升主要表现方面

## 静态提升

元素没有绑定动态内容，不会改变的节点，会提升到 render 函数外面，不写入 render 函数 -静态属性也会提升

## 预字符串化

当编译器遇到大量连续的静态内容，会直接将其编译为一个普通字符串节点

vue2:会编译成虚拟节点
vue3:动态节点需要记录，静态节点变成字符串

## 缓存事件处理函数

vue2:事件处理函数 render 编译成函数
vue3:会有缓存事件处理函数，不会轻易变化。\_cache 缓存对象，事件函数编译成函数有的话直接返回，没有的话执行函数。

# Block Tree

vue2:对比新旧两棵树，会一层一层比较，静态动态节点都会对比，浪费大多数时间在静态节点上
vue3:Block 根节点中编译器会记录动态节点，然后对动态节点树进行遍历。

## PatchFlag

vue2:在对比每一个节点时，并不知道这个节点哪些相关信息会发生化，因此只能将所有信息依次比对。
vue3: 标记记录动态节点内容是那一块，仅比较标记内容。

# vue3 去掉了 Vue 构造函数

vue2 的全局构造函数带来了诸多问题：

1. 调用构造函数的静态方法会对所有 vue 应用生效，不利于隔离不同应用
2. vue2 的构造函数集成了太多功能，不利于 tree shaking，vue3 把这些功能使用普通函数导出，能够充分利用 tree shaking 优化打包体积
3. vue2 没有把组件实例和 vue 应用两个概念区分开，在 vue2 中，通过 new Vue 创建的对象，既是一个 vue 应用，同时又是一个特殊的 vue 组件。vue3 中，把两个概念区别开来，通过 createApp 创建的对象，是一个 vue 应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件。

# 对 vue3 数据响应式的理解

vue3 不再使用 Object.defineProperty 的方式定义完成数据响应式，而是使用 Proxy。
除了 Proxy 本身效率比 Object.defineProperty 更高之外，由于不必递归遍历所有属性，而是直接得到一个 Proxy。所以在 vue3 中，对数据的访问是动态的，当访问某个属性的时候，再动态的获取和设置，这就极大的提升了在组件初始阶段的效率。
同时，由于 Proxy 可以监控到成员的新增和删除，因此，在 vue3 中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在 vue2 中是难以做到的。

# 相比与 vue3 vue2 的诟病点

`vue2`比较让人诟病的一点就是提供了两种双向绑定：`v-model`和`.sync`，在`vue3`中，去掉了`.sync`修饰符，只需要使用`v-model`进行双向绑定即可。
为了让`v-model`更好的针对多个属性进行双向绑定，`vue3`作出了以下修改
当对自定义组件使用`v-model`指令时，绑定的属性名由原来的`value`变为`modelValue`，事件名由原来的`input`变为`update:modelValue`
`vue3`现在允许组件出现多个根节点

# 获取响应式数据

| API        | 传入                      | 返回             | 备注                                                                                                                                 |
| :--------- | ------------------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `reactive` | `plain-object`            | `对象代理`       | 深度代理对象中的所有成员                                                                                                             |
| `readonly` | `plain-object` or `proxy` | `对象代理`       | 只能读取代理对象中的成员，不可修改                                                                                                   |
| `ref`      | `any`                     | `{ value: ... }` | 对 value 的访问是响应式的<br />如果给 value 的值是一个对象，<br />则会通过`reactive`函数进行代理<br />如果已经是代理，则直接使用代理 |
| `computed` | `function`                | `{ value: ... }` | 当读取 value 值时，<br />会**根据情况**决定是否要运行函数                                                                            |

应用：

- 如果想要让一个对象变为响应式数据，可以使用`reactive`或`ref`
- 如果想要让一个对象的所有属性只读，使用`readonly`
- 如果想要让一个非对象数据变为响应式数据，使用`ref`
- 如果想要根据已知的响应式数据得到一个新的响应式数据，使用`computed`

# 监听数据的变化

## watchEffect

该函数会立即执行，然后追中函数中用到的响应式数据，响应式数据变化后会再次执行

```js
const stop = watchEffect(() => {});
// 通过调用stop函数，会停止监听
stop(); // 停止监听
```

## watch

```js
// 等效于vue2的$watch

// 监听单个数据的变化
const state = reactive({ count: 0 });
watch(
  () => state.count,
  (newValue, oldValue) => {
    // ...
  },
  options
);

const countRef = ref(0);
watch(
  countRef,
  (newValue, oldValue) => {
    // ...
  },
  options
);

// 监听多个数据的变化
watch([() => state.count, countRef], ([new1, new2], [old1, old2]) => {
  // ...
});
```

**注意：无论是`watchEffect`还是`watch`，当依赖项变化时，回调函数的运行都是异步的（微队列）**
应用：除非遇到下面的场景，否则均建议选择`watchEffect`

- 不希望回调函数一开始就执行
- 数据改变时，需要参考旧值
- 需要监控一些回调函数中不会用到的数据

# 判断

| API          | 含义                                                                                                       |
| ------------ | ---------------------------------------------------------------------------------------------------------- |
| `isProxy`    | 判断某个数据是否是由`reactive`或`readonly`                                                                 |
| `isReactive` | 判断某个数据是否是通过`reactive`创建的<br />详细:https://v3.vuejs.org/api/basic-reactivity.html#isreactive |
| `isReadonly` | 判断某个数据是否是通过`readonly`创建的                                                                     |
| `isRef`      | 判断某个数据是否是一个`ref`对象                                                                            |

# 转换

**unref**
如果参数是 ref，则返回内部值，否则返回参数本身。
这是 val = isRef(val) ? val.value : val 计算的一个语法糖。

**toRef**

得到一个响应式对象某个属性的 ref 格式

```js
const state = reactive({
  foo: 1,
  bar: 2,
});

const fooRef = toRef(state, "foo"); //
```
