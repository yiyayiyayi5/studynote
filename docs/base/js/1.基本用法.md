## let,var 和 const 命令

### let 命令

- let 命令所在代码块内有效

  > for 循环的计数器内适合用 let 命令，在循环体外使用会报错。同时 js 引擎内部会记住上一轮循环的值，并不影响循环的进行。

- 暂时性死区:使用 let 命令声明变量之前，该变量都是不可用的.只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
  > “暂时性死区”也意味着 typeof 不再是一个百分之百安全的操作。但如果该变量没有被声明，使用`typeof`反而不会报错。

```js
var tmp = 123;
if (true) {
  tmp = "abc"; // ReferenceError
  let tmp;
}

typeof x; // ReferenceError
let x;
```

- let 不允许在相同作用域内，重复声明同一个变量。

### var 命令

var 全局范围内有效。

var 会发生变量提升，可以在变量声明之前使用，值为 undefinded.

```js
{
  let a = 10;
  var b = 20;
}
console.log(a); // ReferenceError: a is not defined.
console.log(b); //20
```

### const 命令

const 声明一个只读的常量。一旦声明，常量的值就不能改变。

const 一旦声明变量，就必须立即初始化，不能留到以后赋值。

const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。

const 声明的常量储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把将该常量指向另一个地址，但对象本身是可变的，依然可以为其添加新属性。

## 块级作用域

- ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
- ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。

  > ES6 规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式:

  > 允许在块级作用域内声明函数。
  >
  > 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。
  >
  > 同时，函数声明还会提升到所在的块级作用域的头部。
  > **注意**:应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式，而不是函数声明语句

```js
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = "secret";
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = "secret";
  let f = function () {
    return a;
  };
}
```

## 解构赋值

解构赋值写法，“模式匹配”：

```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo; // 1
bar; // 2
baz; // 3

let [, , third] = ["foo", "bar", "baz"];
third; // "baz"

let [x, , y] = [1, 2, 3];
x; // 1
y; // 3

let [head, ...tail] = [1, 2, 3, 4];
head; // 1
tail; // [2, 3, 4]

let [x, y, ...z] = ["a"];
x; // "a"
y; // undefined
z; // []
```

### 解构赋值指定默认值

```js
let [foo = true] = [];
foo; // true

let [x, y = "b"] = ["a"]; // x='a', y='b'
```

如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

```js
function f() {
  console.log("aaa");
}

let [x = f()] = [1];

//因为上面的代码x能取到值，所以函数根本不会执行
```

### 对象解构赋值

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。

```js
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz; // "aaa"
foo; // error: foo is not defined
```

上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。
